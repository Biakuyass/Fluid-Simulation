//
// FX Version: fx_5_0
//
// 1 local buffer(s)
//
cbuffer cbObject
{
    float4x4 matWorldViewProj;          // Offset:    0, size:   64
    float4x4 matWorld;                  // Offset:   64, size:   64
    float4x4 matWorldInverseTranspose;  // Offset:  128, size:   64
    float3  EyePos;                     // Offset:  192, size:   12
    float3  LightDir;                   // Offset:  208, size:   12
    float   SkyBoxRange;                // Offset:  220, size:    4
    float2  TexUV[4] = { 0, 0, 1, 0, 0, 1, 1, 1 };// Offset:  224, size:   56
}

//
// 3 local object(s)
//
Texture2D gTexture;
TextureCube gCubeTexture;
SamplerState samAnisotropic
{
    Filter   = uint(ANISOTROPIC /* 85 */);
    MaxAnisotropy = uint(4);
    AddressU = uint(WRAP /* 1 */);
    AddressV = uint(WRAP /* 1 */);
};

//
// 1 groups(s)
//
fxgroup
{
    //
    // 6 technique(s)
    //
    technique11 BasicTech
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64
                //   float4x4 matWorld;                 // Offset:   64 Size:    64
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64
                //   float3 EyePos;                     // Offset:  192 Size:    12 [unused]
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4 [unused]
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSITION                 0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                // SIZE                     0   xy          3     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float   xyzw
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float   xy  
                // SIZE                     0     zw        3     NONE  float     zw
                // TEXCOORD                 1   xyz         4     NONE  float   xyz 
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[11], immediateIndexed
                dcl_input v0.xyz
                dcl_input v1.xyz
                dcl_input v2.xy
                dcl_input v3.xy
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xyz
                dcl_output o3.xy
                dcl_output o3.zw
                dcl_output o4.xyz
                dcl_temps 5
                
                #line 57 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, v0.xyzx  // vout<12,13,14>
                mov r1.xyz, v0.xyzx
                mov r1.w, l(1.000000)
                dp4 r2.x, r1.xyzw, cb0[0].xyzw  // vout<0:NaN:Inf>
                dp4 r2.y, r1.xyzw, cb0[1].xyzw  // vout<1:NaN:Inf>
                dp4 r2.z, r1.xyzw, cb0[2].xyzw  // vout<2:NaN:Inf>
                dp4 r2.w, r1.xyzw, cb0[3].xyzw  // vout<3:NaN:Inf>
                dp4 r3.x, r1.xyzw, cb0[4].xyzw  // vout<4:NaN:Inf>
                dp4 r3.y, r1.xyzw, cb0[5].xyzw  // vout<5:NaN:Inf>
                dp4 r3.z, r1.xyzw, cb0[6].xyzw  // vout<6:NaN:Inf>
                dp3 r1.x, v1.xyzx, cb0[8].xyzx
                dp3 r1.y, v1.xyzx, cb0[9].xyzx
                dp3 r1.z, v1.xyzx, cb0[10].xyzx
                dp3 r0.w, r1.xyzx, r1.xyzx
                rsq r0.w, r0.w
                mul r1.xyz, r0.wwww, r1.xyzx  // vout<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov r4.xy, v2.xyxx  // vout<10,11>
                mov r4.zw, v3.xxxy  // vout<15,16>
                
                #line 65
                mov o0.xyzw, r2.xyzw  // VS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                mov o3.xy, r4.xyxx  // VS<10,11>
                mov o3.zw, r4.zzzw  // VS<15,16>
                mov o1.xyz, r3.xyzx  // VS<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                mov o2.xyz, r1.xyzx  // VS<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov o4.xyz, r0.xyzx  // VS<12,13,14>
                ret 
                // Approximately 25 instruction slots used
                            
            };
            GeometryShader = NULL;
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64 [unused]
                //   float4x4 matWorld;                 // Offset:   64 Size:    64 [unused]
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64 [unused]
                //   float3 EyePos;                     // Offset:  192 Size:    12
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // samAnisotropic                    sampler      NA          NA    0        1
                // gCubeTexture                      texture  float4        cube    0        1
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float       
                // SIZE                     0     zw        3     NONE  float       
                // TEXCOORD                 1   xyz         4     NONE  float       
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_Target                0   xyzw        0   TARGET  float   xyzw
                //
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[14], immediateIndexed
                dcl_sampler s0, mode_default
                dcl_resource_texturecube (float,float,float,float) t0
                dcl_input_ps linear v1.xyz
                dcl_input_ps linear v2.xyz
                dcl_output o0.xyzw
                dcl_temps 6
                dcl_indexableTemp x0[6], 4
                dcl_indexableTemp x1[6], 4
                
                #line 173 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, -v1.xyzx
                add r0.xyz, r0.xyzx, cb0[12].xyzx
                dp3 r0.w, r0.xyzx, r0.xyzx
                rsq r0.w, r0.w
                mul r0.xyz, r0.wwww, r0.xyzx  // PostoEye<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 190
                dp3 r0.w, r0.xyzx, r0.xyzx
                rsq r0.w, r0.w
                mul r0.xyz, r0.wwww, r0.xyzx
                mov r0.xyz, -r0.xyzx  // incident<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                dp3 r0.w, r0.xyzx, v2.xyzx
                add r1.x, r0.w, r0.w
                mov r1.x, -r1.x
                mul r1.xyz, r1.xxxx, v2.xyzx
                add r1.xyz, r0.xyzx, r1.xyzx
                dp3 r1.w, r1.xyzx, r1.xyzx
                rsq r1.w, r1.w
                mul r1.xyz, r1.wwww, r1.xyzx  // reflectionvector<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                nop 
                mov r2.xyz, v1.xyzx  // p<0,1,2>
                mov r1.xyz, r1.xyzx  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 115
                mov r1.w, cb0[13].w  // range<0>
                ne r2.w, r1.x, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.x
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.x
                  mov x0[0].x, r3.x  // t<0>
                else 
                
                #line 120
                  mov x0[0].x, l(-1.000000)  // t<0>
                
                #line 117
                endif 
                
                #line 122
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.x
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.x
                  mov x0[1].x, r2.w  // t<1>
                else 
                
                #line 125
                  mov x0[1].x, l(-1.000000)  // t<1>
                
                #line 122
                endif 
                
                #line 127
                ne r2.w, r1.y, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.y
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.y
                  mov x0[2].x, r3.x  // t<2>
                else 
                
                #line 130
                  mov x0[2].x, l(-1.000000)  // t<2>
                
                #line 127
                endif 
                
                #line 132
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.y
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.y
                  mov x0[3].x, r2.w  // t<3>
                else 
                
                #line 135
                  mov x0[3].x, l(-1.000000)  // t<3>
                
                #line 132
                endif 
                
                #line 137
                ne r2.w, r1.z, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.z
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.z
                  mov x0[4].x, r3.x  // t<4>
                else 
                
                #line 140
                  mov x0[4].x, l(-1.000000)  // t<4>
                
                #line 137
                endif 
                
                #line 142
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.z
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.z
                  mov x0[5].x, r2.w  // t<5>
                else 
                
                #line 145
                  mov x0[5].x, l(-1.000000)  // t<5>
                
                #line 142
                endif 
                
                #line 147
                mov r2.w, l(100000.000000)  // tre<0: 100000f>
                mov r3.x, l(0)  // i<0: 0>
                mov r3.y, r2.w  // tre<0:NaN:Inf>
                mov r3.z, r3.x  // i<0>
                loop 
                  ilt r3.w, r3.z, l(6)
                  breakc_z r3.w
                  mov r3.w, r3.z
                  mov r3.w, x0[r3.w + 0].x  // t<0:NaN:Inf>
                  ge r4.x, r3.w, l(0.000000)
                  lt r4.y, r3.w, r3.y
                  and r4.x, r4.y, r4.x
                  if_nz r4.x
                    mov r3.y, r3.w  // tre<0:NaN:Inf>
                  endif 
                  iadd r3.z, r3.z, l(1)  // i<0>
                endloop 
                
                #line 156
                mul r1.x, r1.x, r3.y
                add r4.x, r1.x, r2.x  // intersectPoint<0:NaN:Inf>
                mul r1.x, r1.y, r3.y
                add r4.y, r1.x, r2.y  // intersectPoint<1:NaN:Inf>
                mul r1.x, r1.z, r3.y
                add r4.z, r1.x, r2.z  // intersectPoint<2:NaN:Inf>
                
                #line 161
                mov r4.x, r4.x  // Intersect<0:NaN:Inf>
                mov r4.y, r4.y  // Intersect<1:NaN:Inf>
                mov r4.z, r4.z  // Intersect<2:NaN:Inf>
                
                #line 193
                mov r4.xyz, r4.xyzx  // reflect_point<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                sample_indexable(texturecube)(float,float,float,float) r1.xyz, r4.xyzx, t0.xyzw, s0
                mov r1.xyz, r1.xyzx  // ReflectColor<0:Inf,1:Inf,2:Inf>
                
                #line 198
                mul r3.y, r0.w, r0.w
                mov r3.y, -r3.y
                add r3.y, r3.y, l(1.000000)
                mul r3.y, r3.y, l(0.810000)
                mov r3.y, -r3.y
                add r3.y, r3.y, l(1.000000)
                sqrt r3.z, r3.y
                mul r0.w, r0.w, l(0.900000)
                add r0.w, r3.z, r0.w
                ge r3.y, r3.y, l(0.000000)
                mul r4.xyz, r0.xyzx, l(0.900000, 0.900000, 0.900000, 0.000000)
                mul r5.xyz, r0.wwww, v2.xyzx
                mov r5.xyz, -r5.xyzx
                add r4.xyz, r4.xyzx, r5.xyzx
                movc r3.yzw, r3.yyyy, r4.xxyz, l(0,0,0,0)
                dp3 r0.w, r3.yzwy, r3.yzwy
                rsq r0.w, r0.w
                mul r3.yzw, r0.wwww, r3.yyzw  // refractionvector<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                nop 
                mov r3.yzw, r3.yyzw  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 117
                ne r0.w, r3.y, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.x
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.y
                  mov x1[0].x, r4.x  // t<0>
                else 
                
                #line 120
                  mov x1[0].x, l(-1.000000)  // t<0>
                
                #line 117
                endif 
                
                #line 122
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r4.x, -r2.x
                  add r0.w, r0.w, r4.x
                  div r0.w, r0.w, r3.y
                  mov x1[1].x, r0.w  // t<1>
                else 
                
                #line 125
                  mov x1[1].x, l(-1.000000)  // t<1>
                
                #line 122
                endif 
                
                #line 127
                ne r0.w, r3.z, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.y
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.z
                  mov x1[2].x, r4.x  // t<2>
                else 
                
                #line 130
                  mov x1[2].x, l(-1.000000)  // t<2>
                
                #line 127
                endif 
                
                #line 132
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r4.x, -r2.y
                  add r0.w, r0.w, r4.x
                  div r0.w, r0.w, r3.z
                  mov x1[3].x, r0.w  // t<3>
                else 
                
                #line 135
                  mov x1[3].x, l(-1.000000)  // t<3>
                
                #line 132
                endif 
                
                #line 137
                ne r0.w, r3.w, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.z
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.w
                  mov x1[4].x, r4.x  // t<4>
                else 
                
                #line 140
                  mov x1[4].x, l(-1.000000)  // t<4>
                
                #line 137
                endif 
                
                #line 142
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r1.w, -r2.z
                  add r0.w, r0.w, r1.w
                  div r0.w, r0.w, r3.w
                  mov x1[5].x, r0.w  // t<5>
                else 
                
                #line 145
                  mov x1[5].x, l(-1.000000)  // t<5>
                
                #line 142
                endif 
                
                #line 148
                mov r4.x, r2.w  // tre<0:NaN:Inf>
                mov r4.y, r3.x  // i<0>
                loop 
                  ilt r0.w, r4.y, l(6)
                  breakc_z r0.w
                  mov r0.w, r4.y
                  mov r0.w, x1[r0.w + 0].x  // t<0:NaN:Inf>
                  ge r1.w, r0.w, l(0.000000)
                  lt r4.z, r0.w, r4.x
                  and r1.w, r1.w, r4.z
                  if_nz r1.w
                    mov r4.x, r0.w  // tre<0:NaN:Inf>
                  endif 
                  iadd r4.y, r4.y, l(1)  // i<0>
                endloop 
                
                #line 156
                mul r0.w, r3.y, r4.x
                add r5.x, r0.w, r2.x  // intersectPoint<0:NaN:Inf>
                mul r0.w, r3.z, r4.x
                add r5.y, r0.w, r2.y  // intersectPoint<1:NaN:Inf>
                mul r0.w, r3.w, r4.x
                add r5.z, r0.w, r2.z  // intersectPoint<2:NaN:Inf>
                
                #line 161
                mov r5.x, r5.x  // Intersect<0:NaN:Inf>
                mov r5.y, r5.y  // Intersect<1:NaN:Inf>
                mov r5.z, r5.z  // Intersect<2:NaN:Inf>
                
                #line 199
                mov r5.xyz, r5.xyzx  // refract_point<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                sample_indexable(texturecube)(float,float,float,float) r2.xyzw, r5.xyzx, t0.xyzw, s0  // RefractColor<0:Inf,1:Inf,2:Inf,3:Inf>
                
                #line 209
                mov r0.xyz, -r0.xyzx
                dp3 r0.x, r0.xyzx, v2.xyzx
                mov r0.x, -r0.x
                add r0.x, r0.x, l(1.000000)
                mul r0.y, r0.x, l(1.000000)
                mul r0.x, r0.x, r0.x
                mul r0.x, r0.x, r0.x
                mul r0.x, r0.x, r0.y
                mul r0.x, r0.x, l(0.979630)
                add r0.x, r0.x, l(0.020370)  // fastFresnel<0:NaN:Inf>
                
                #line 217
                mul r0.yzw, r0.xxxx, r1.xxyz
                add r1.xyz, r0.yzwy, l(0.000000, 0.000000, 0.000000, 0.000000)  // Color<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov r1.w, l(1.000000)  // Color<3: 1f>
                mov r0.x, -r0.x
                add r0.x, r0.x, l(1.000000)
                mul r0.xyzw, r0.xxxx, r2.xyzw
                add r0.xyzw, r0.xyzw, r1.xyzw  // Color<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                
                #line 223
                mov o0.xyzw, r0.xyzw  // PS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                ret 
                // Approximately 223 instruction slots used
                            
            };
        }

    }

    technique11 SkyboxTech
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64
                //   float4x4 matWorld;                 // Offset:   64 Size:    64
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64
                //   float3 EyePos;                     // Offset:  192 Size:    12 [unused]
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4 [unused]
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSITION                 0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                // SIZE                     0   xy          3     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float   xyzw
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float   xy  
                // SIZE                     0     zw        3     NONE  float     zw
                // TEXCOORD                 1   xyz         4     NONE  float   xyz 
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[11], immediateIndexed
                dcl_input v0.xyz
                dcl_input v1.xyz
                dcl_input v2.xy
                dcl_input v3.xy
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xyz
                dcl_output o3.xy
                dcl_output o3.zw
                dcl_output o4.xyz
                dcl_temps 5
                
                #line 57 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, v0.xyzx  // vout<12,13,14>
                mov r1.xyz, v0.xyzx
                mov r1.w, l(1.000000)
                dp4 r2.x, r1.xyzw, cb0[0].xyzw  // vout<0:NaN:Inf>
                dp4 r2.y, r1.xyzw, cb0[1].xyzw  // vout<1:NaN:Inf>
                dp4 r2.z, r1.xyzw, cb0[2].xyzw  // vout<2:NaN:Inf>
                dp4 r2.w, r1.xyzw, cb0[3].xyzw  // vout<3:NaN:Inf>
                dp4 r3.x, r1.xyzw, cb0[4].xyzw  // vout<4:NaN:Inf>
                dp4 r3.y, r1.xyzw, cb0[5].xyzw  // vout<5:NaN:Inf>
                dp4 r3.z, r1.xyzw, cb0[6].xyzw  // vout<6:NaN:Inf>
                dp3 r1.x, v1.xyzx, cb0[8].xyzx
                dp3 r1.y, v1.xyzx, cb0[9].xyzx
                dp3 r1.z, v1.xyzx, cb0[10].xyzx
                dp3 r0.w, r1.xyzx, r1.xyzx
                rsq r0.w, r0.w
                mul r1.xyz, r0.wwww, r1.xyzx  // vout<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov r4.xy, v2.xyxx  // vout<10,11>
                mov r4.zw, v3.xxxy  // vout<15,16>
                
                #line 65
                mov o0.xyzw, r2.xyzw  // VS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                mov o3.xy, r4.xyxx  // VS<10,11>
                mov o3.zw, r4.zzzw  // VS<15,16>
                mov o1.xyz, r3.xyzx  // VS<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                mov o2.xyz, r1.xyzx  // VS<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov o4.xyz, r0.xyzx  // VS<12,13,14>
                ret 
                // Approximately 25 instruction slots used
                            
            };
            GeometryShader = NULL;
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // samAnisotropic                    sampler      NA          NA    0        1
                // gCubeTexture                      texture  float4        cube    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float       
                // TEXCOORD                 0   xy          3     NONE  float       
                // SIZE                     0     zw        3     NONE  float       
                // TEXCOORD                 1   xyz         4     NONE  float       
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_Target                0   xyzw        0   TARGET  float   xyzw
                //
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_sampler s0, mode_default
                dcl_resource_texturecube (float,float,float,float) t0
                dcl_input_ps linear v1.xyz
                dcl_output o0.xyzw
                dcl_temps 1
                
                #line 306 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                sample_indexable(texturecube)(float,float,float,float) r0.xyzw, v1.xyzx, t0.xyzw, s0  // Color<0:Inf,1:Inf,2:Inf,3:Inf>
                
                #line 309
                mov o0.xyzw, r0.xyzw  // PS_Skybox<0:Inf,1:Inf,2:Inf,3:Inf>
                ret 
                // Approximately 3 instruction slots used
                            
            };
        }

    }

    technique11 WireFrameTech
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64
                //   float4x4 matWorld;                 // Offset:   64 Size:    64
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64
                //   float3 EyePos;                     // Offset:  192 Size:    12 [unused]
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4 [unused]
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSITION                 0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                // SIZE                     0   xy          3     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float   xyzw
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float   xy  
                // SIZE                     0     zw        3     NONE  float     zw
                // TEXCOORD                 1   xyz         4     NONE  float   xyz 
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[11], immediateIndexed
                dcl_input v0.xyz
                dcl_input v1.xyz
                dcl_input v2.xy
                dcl_input v3.xy
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xyz
                dcl_output o3.xy
                dcl_output o3.zw
                dcl_output o4.xyz
                dcl_temps 5
                
                #line 57 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, v0.xyzx  // vout<12,13,14>
                mov r1.xyz, v0.xyzx
                mov r1.w, l(1.000000)
                dp4 r2.x, r1.xyzw, cb0[0].xyzw  // vout<0:NaN:Inf>
                dp4 r2.y, r1.xyzw, cb0[1].xyzw  // vout<1:NaN:Inf>
                dp4 r2.z, r1.xyzw, cb0[2].xyzw  // vout<2:NaN:Inf>
                dp4 r2.w, r1.xyzw, cb0[3].xyzw  // vout<3:NaN:Inf>
                dp4 r3.x, r1.xyzw, cb0[4].xyzw  // vout<4:NaN:Inf>
                dp4 r3.y, r1.xyzw, cb0[5].xyzw  // vout<5:NaN:Inf>
                dp4 r3.z, r1.xyzw, cb0[6].xyzw  // vout<6:NaN:Inf>
                dp3 r1.x, v1.xyzx, cb0[8].xyzx
                dp3 r1.y, v1.xyzx, cb0[9].xyzx
                dp3 r1.z, v1.xyzx, cb0[10].xyzx
                dp3 r0.w, r1.xyzx, r1.xyzx
                rsq r0.w, r0.w
                mul r1.xyz, r0.wwww, r1.xyzx  // vout<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov r4.xy, v2.xyxx  // vout<10,11>
                mov r4.zw, v3.xxxy  // vout<15,16>
                
                #line 65
                mov o0.xyzw, r2.xyzw  // VS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                mov o3.xy, r4.xyxx  // VS<10,11>
                mov o3.zw, r4.zzzw  // VS<15,16>
                mov o1.xyz, r3.xyzx  // VS<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                mov o2.xyz, r1.xyzx  // VS<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov o4.xyz, r0.xyzx  // VS<12,13,14>
                ret 
                // Approximately 25 instruction slots used
                            
            };
            GeometryShader = NULL;
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // POSITION                 0   xyz         1     NONE  float       
                // NORMAL                   0   xyz         2     NONE  float       
                // TEXCOORD                 0   xy          3     NONE  float       
                // SIZE                     0     zw        3     NONE  float       
                // TEXCOORD                 1   xyz         4     NONE  float       
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_Target                0   xyzw        0   TARGET  float   xyzw
                //
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_output o0.xyzw
                
                #line 352 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov o0.xyzw, l(1.000000,1.000000,1.000000,0.500000)  // PS_WireFrame<0: 1f,1: 1f,2: 1f,3: 0.5f>
                ret 
                // Approximately 2 instruction slots used
                            
            };
        }

    }

    technique11 BillBoardTech
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64
                //   float4x4 matWorld;                 // Offset:   64 Size:    64
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64
                //   float3 EyePos;                     // Offset:  192 Size:    12 [unused]
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4 [unused]
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSITION                 0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                // SIZE                     0   xy          3     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float   xyzw
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float   xy  
                // SIZE                     0     zw        3     NONE  float     zw
                // TEXCOORD                 1   xyz         4     NONE  float   xyz 
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[11], immediateIndexed
                dcl_input v0.xyz
                dcl_input v1.xyz
                dcl_input v2.xy
                dcl_input v3.xy
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xyz
                dcl_output o3.xy
                dcl_output o3.zw
                dcl_output o4.xyz
                dcl_temps 5
                
                #line 57 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, v0.xyzx  // vout<12,13,14>
                mov r1.xyz, v0.xyzx
                mov r1.w, l(1.000000)
                dp4 r2.x, r1.xyzw, cb0[0].xyzw  // vout<0:NaN:Inf>
                dp4 r2.y, r1.xyzw, cb0[1].xyzw  // vout<1:NaN:Inf>
                dp4 r2.z, r1.xyzw, cb0[2].xyzw  // vout<2:NaN:Inf>
                dp4 r2.w, r1.xyzw, cb0[3].xyzw  // vout<3:NaN:Inf>
                dp4 r3.x, r1.xyzw, cb0[4].xyzw  // vout<4:NaN:Inf>
                dp4 r3.y, r1.xyzw, cb0[5].xyzw  // vout<5:NaN:Inf>
                dp4 r3.z, r1.xyzw, cb0[6].xyzw  // vout<6:NaN:Inf>
                dp3 r1.x, v1.xyzx, cb0[8].xyzx
                dp3 r1.y, v1.xyzx, cb0[9].xyzx
                dp3 r1.z, v1.xyzx, cb0[10].xyzx
                dp3 r0.w, r1.xyzx, r1.xyzx
                rsq r0.w, r0.w
                mul r1.xyz, r0.wwww, r1.xyzx  // vout<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov r4.xy, v2.xyxx  // vout<10,11>
                mov r4.zw, v3.xxxy  // vout<15,16>
                
                #line 65
                mov o0.xyzw, r2.xyzw  // VS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                mov o3.xy, r4.xyxx  // VS<10,11>
                mov o3.zw, r4.zzzw  // VS<15,16>
                mov o1.xyz, r3.xyzx  // VS<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                mov o2.xyz, r1.xyzx  // VS<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov o4.xyz, r0.xyzx  // VS<12,13,14>
                ret 
                // Approximately 25 instruction slots used
                            
            };
            GeometryShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64
                //   float4x4 matWorld;                 // Offset:   64 Size:    64 [unused]
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64 [unused]
                //   float3 EyePos;                     // Offset:  192 Size:    12
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4 [unused]
                //   float2 TexUV[4];                   // Offset:  224 Size:    56
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // POSITION                 0   xyz         1     NONE  float       
                // NORMAL                   0   xyz         2     NONE  float       
                // TEXCOORD                 0   xy          3     NONE  float       
                // SIZE                     0     zw        3     NONE  float     zw
                // TEXCOORD                 1   xyz         4     NONE  float   xyz 
                // SV_PrimitiveID           0    N/A   primID   PRIMID   uint    YES
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // m0:SV_POSITION           0   xyzw        0      POS  float   xyzw
                // m0:POSITION              0   xyz         1     NONE  float   xyz 
                // m0:NORMAL                0   xyz         2     NONE  float   xyz 
                // m0:TEXCOORD              0   xy          3     NONE  float   xy  
                // m0:SV_PrimitiveID        0   x           4   PRIMID   uint   x   
                //
                gs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[18], dynamicIndexed
                dcl_input_siv v[1][0].xyzw, position
                dcl_input v[1][1].xyz
                dcl_input v[1][2].xyz
                dcl_input v[1][3].xy
                dcl_input v[1][3].zw
                dcl_input v[1][4].xyz
                dcl_input vPrim
                dcl_temps 5
                dcl_indexableTemp x0[4], 4
                dcl_inputprimitive point 
                dcl_stream m0
                dcl_outputtopology trianglestrip 
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xyz
                dcl_output o3.xy
                dcl_output_sgv o4.x, primitive_id
                dcl_maxout 6
                
                #line 73 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, -v[0][4].xyzx
                add r0.xyz, r0.xyzx, cb0[12].xyzx
                dp3 r0.w, r0.xyzx, r0.xyzx
                rsq r0.w, r0.w
                mul r0.xyz, r0.wwww, r0.xyzx  // look<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 76
                mul r1.xyz, r0.zxyz, l(1.000000, 0.000000, 0.000000, 0.000000)
                mul r2.xyz, r0.yzxy, l(0.000000, 0.000000, 1.000000, 0.000000)
                mov r2.xyz, -r2.xyzx
                add r1.xyz, r1.xyzx, r2.xyzx
                dp3 r0.w, r1.xyzx, r1.xyzx
                rsq r0.w, r0.w
                mul r1.xyz, r0.wwww, r1.xyzx  // right<0:NaN:Inf,1: 0f,2:NaN:Inf>
                mul r2.xyz, r0.yzxy, r1.zxyz
                mul r3.xyz, r0.zxyz, r1.yzxy
                mov r3.xyz, -r3.xyzx
                add r2.xyz, r2.xyzx, r3.xyzx  // up<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 81
                div r0.w, v[0][3].z, l(2.000000)
                mul r1.xyz, r1.xyzx, r0.wwww
                mov r3.xyz, -r1.xyzx
                add r3.xyz, r3.xyzx, v[0][4].xyzx
                div r0.w, v[0][3].w, l(2.000000)
                mul r2.xyz, r2.xyzx, r0.wwww
                add r4.xyz, r2.xyzx, r3.xyzx
                mov r4.w, l(1.000000)
                mov x0[0].xyzw, r4.xyzw  // v<0,1,2,3>
                add r1.xyz, r1.xyzx, v[0][4].xyzx
                add r4.xyz, r2.xyzx, r1.xyzx
                mov r4.w, l(1.000000)
                mov x0[1].xyzw, r4.xyzw  // v<4,5,6,7>
                mov r2.xyz, -r2.xyzx
                add r3.xyz, r2.xyzx, r3.xyzx
                mov r3.w, l(1.000000)
                mov x0[2].xyzw, r3.xyzw  // v<8,9,10,11>
                add r1.xyz, r1.xyzx, r2.xyzx
                mov r1.w, l(1.000000)
                mov x0[3].xyzw, r1.xyzw  // v<12,13,14,15>
                
                #line 97
                mov r0.w, l(0)  // i<0: 0>
                mov r1.x, r0.w  // i<0>
                loop 
                  ilt r1.y, r1.x, l(4)
                  breakc_z r1.y
                
                #line 100
                  mov r1.y, r1.x
                  mov r2.xyz, x0[r1.y + 0].xyzx  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                  mov r2.xyz, r2.xyzx  // geo<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                  mov r3.xyzw, x0[r1.y + 0].xyzw  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:Inf>
                  dp4 r4.x, r3.xyzw, cb0[0].xyzw  // geo<0:NaN:Inf>
                  dp4 r4.y, r3.xyzw, cb0[1].xyzw  // geo<1:NaN:Inf>
                  dp4 r4.z, r3.xyzw, cb0[2].xyzw  // geo<2:NaN:Inf>
                  dp4 r4.w, r3.xyzw, cb0[3].xyzw  // geo<3:NaN:Inf>
                  mov r3.xyz, r0.xyzx  // geo<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                  mov r1.yz, cb0[r1.y + 14].xxyx  // geo<10,11>
                  mov r1.w, vPrim  // geo<12>
                  mov o0.xyzw, r4.xyzw  // triStream<0,0,0,0>
                  mov o1.xyz, r2.xyzx  // triStream<0,0,0>
                  mov o2.xyz, r3.xyzx  // triStream<0,0,0>
                  mov o3.xy, r1.yzyy  // triStream<0,0>
                  mov o4.x, r1.w  // triStream<0>
                  emit_stream m0
                
                #line 97
                  iadd r1.x, r1.x, l(1)  // i<0>
                endloop 
                
                #line 69
                ret 
                // Approximately 61 instruction slots used
                            
            };
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // samAnisotropic                    sampler      NA          NA    0        1
                // gTexture                          texture  float4          2d    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // POSITION                 0   xyz         1     NONE  float       
                // NORMAL                   0   xyz         2     NONE  float       
                // TEXCOORD                 0   xy          3     NONE  float   xy  
                // SV_PrimitiveID           0   x           4   PRIMID   uint       
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_Target                0   xyzw        0   TARGET  float   xyzw
                //
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_sampler s0, mode_default
                dcl_resource_texture2d (float,float,float,float) t0
                dcl_input_ps linear v3.xy
                dcl_output o0.xyzw
                dcl_temps 1
                
                #line 262 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v3.xyxx, t0.xyzw, s0  // Color<0:Inf,1:Inf,2:Inf,3:Inf>
                
                #line 265
                mov o0.xyzw, r0.xyzw  // PS_BillBoard<0:Inf,1:Inf,2:Inf,3:Inf>
                ret 
                // Approximately 3 instruction slots used
                            
            };
        }

    }

    technique11 TransparentTech
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64
                //   float4x4 matWorld;                 // Offset:   64 Size:    64
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64
                //   float3 EyePos;                     // Offset:  192 Size:    12 [unused]
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4 [unused]
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSITION                 0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                // SIZE                     0   xy          3     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float   xyzw
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float   xy  
                // SIZE                     0     zw        3     NONE  float     zw
                // TEXCOORD                 1   xyz         4     NONE  float   xyz 
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[11], immediateIndexed
                dcl_input v0.xyz
                dcl_input v1.xyz
                dcl_input v2.xy
                dcl_input v3.xy
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xyz
                dcl_output o3.xy
                dcl_output o3.zw
                dcl_output o4.xyz
                dcl_temps 5
                
                #line 57 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, v0.xyzx  // vout<12,13,14>
                mov r1.xyz, v0.xyzx
                mov r1.w, l(1.000000)
                dp4 r2.x, r1.xyzw, cb0[0].xyzw  // vout<0:NaN:Inf>
                dp4 r2.y, r1.xyzw, cb0[1].xyzw  // vout<1:NaN:Inf>
                dp4 r2.z, r1.xyzw, cb0[2].xyzw  // vout<2:NaN:Inf>
                dp4 r2.w, r1.xyzw, cb0[3].xyzw  // vout<3:NaN:Inf>
                dp4 r3.x, r1.xyzw, cb0[4].xyzw  // vout<4:NaN:Inf>
                dp4 r3.y, r1.xyzw, cb0[5].xyzw  // vout<5:NaN:Inf>
                dp4 r3.z, r1.xyzw, cb0[6].xyzw  // vout<6:NaN:Inf>
                dp3 r1.x, v1.xyzx, cb0[8].xyzx
                dp3 r1.y, v1.xyzx, cb0[9].xyzx
                dp3 r1.z, v1.xyzx, cb0[10].xyzx
                dp3 r0.w, r1.xyzx, r1.xyzx
                rsq r0.w, r0.w
                mul r1.xyz, r0.wwww, r1.xyzx  // vout<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov r4.xy, v2.xyxx  // vout<10,11>
                mov r4.zw, v3.xxxy  // vout<15,16>
                
                #line 65
                mov o0.xyzw, r2.xyzw  // VS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                mov o3.xy, r4.xyxx  // VS<10,11>
                mov o3.zw, r4.zzzw  // VS<15,16>
                mov o1.xyz, r3.xyzx  // VS<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                mov o2.xyz, r1.xyzx  // VS<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov o4.xyz, r0.xyzx  // VS<12,13,14>
                ret 
                // Approximately 25 instruction slots used
                            
            };
            GeometryShader = NULL;
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64 [unused]
                //   float4x4 matWorld;                 // Offset:   64 Size:    64 [unused]
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64 [unused]
                //   float3 EyePos;                     // Offset:  192 Size:    12
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // samAnisotropic                    sampler      NA          NA    0        1
                // gCubeTexture                      texture  float4        cube    0        1
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float       
                // SIZE                     0     zw        3     NONE  float       
                // TEXCOORD                 1   xyz         4     NONE  float       
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_Target                0   xyzw        0   TARGET  float   xyzw
                //
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[14], immediateIndexed
                dcl_sampler s0, mode_default
                dcl_resource_texturecube (float,float,float,float) t0
                dcl_input_ps linear v1.xyz
                dcl_input_ps linear v2.xyz
                dcl_output o0.xyzw
                dcl_temps 6
                dcl_indexableTemp x0[6], 4
                dcl_indexableTemp x1[6], 4
                
                #line 173 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, -v1.xyzx
                add r0.xyz, r0.xyzx, cb0[12].xyzx
                dp3 r0.w, r0.xyzx, r0.xyzx
                rsq r0.w, r0.w
                mul r0.xyz, r0.wwww, r0.xyzx  // PostoEye<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 190
                dp3 r0.w, r0.xyzx, r0.xyzx
                rsq r0.w, r0.w
                mul r0.xyz, r0.wwww, r0.xyzx
                mov r0.xyz, -r0.xyzx  // incident<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                dp3 r0.w, r0.xyzx, v2.xyzx
                add r1.x, r0.w, r0.w
                mov r1.x, -r1.x
                mul r1.xyz, r1.xxxx, v2.xyzx
                add r1.xyz, r0.xyzx, r1.xyzx
                dp3 r1.w, r1.xyzx, r1.xyzx
                rsq r1.w, r1.w
                mul r1.xyz, r1.wwww, r1.xyzx  // reflectionvector<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                nop 
                mov r2.xyz, v1.xyzx  // p<0,1,2>
                mov r1.xyz, r1.xyzx  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 115
                mov r1.w, cb0[13].w  // range<0>
                ne r2.w, r1.x, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.x
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.x
                  mov x0[0].x, r3.x  // t<0>
                else 
                
                #line 120
                  mov x0[0].x, l(-1.000000)  // t<0>
                
                #line 117
                endif 
                
                #line 122
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.x
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.x
                  mov x0[1].x, r2.w  // t<1>
                else 
                
                #line 125
                  mov x0[1].x, l(-1.000000)  // t<1>
                
                #line 122
                endif 
                
                #line 127
                ne r2.w, r1.y, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.y
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.y
                  mov x0[2].x, r3.x  // t<2>
                else 
                
                #line 130
                  mov x0[2].x, l(-1.000000)  // t<2>
                
                #line 127
                endif 
                
                #line 132
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.y
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.y
                  mov x0[3].x, r2.w  // t<3>
                else 
                
                #line 135
                  mov x0[3].x, l(-1.000000)  // t<3>
                
                #line 132
                endif 
                
                #line 137
                ne r2.w, r1.z, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.z
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.z
                  mov x0[4].x, r3.x  // t<4>
                else 
                
                #line 140
                  mov x0[4].x, l(-1.000000)  // t<4>
                
                #line 137
                endif 
                
                #line 142
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.z
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.z
                  mov x0[5].x, r2.w  // t<5>
                else 
                
                #line 145
                  mov x0[5].x, l(-1.000000)  // t<5>
                
                #line 142
                endif 
                
                #line 147
                mov r2.w, l(100000.000000)  // tre<0: 100000f>
                mov r3.x, l(0)  // i<0: 0>
                mov r3.y, r2.w  // tre<0:NaN:Inf>
                mov r3.z, r3.x  // i<0>
                loop 
                  ilt r3.w, r3.z, l(6)
                  breakc_z r3.w
                  mov r3.w, r3.z
                  mov r3.w, x0[r3.w + 0].x  // t<0:NaN:Inf>
                  ge r4.x, r3.w, l(0.000000)
                  lt r4.y, r3.w, r3.y
                  and r4.x, r4.y, r4.x
                  if_nz r4.x
                    mov r3.y, r3.w  // tre<0:NaN:Inf>
                  endif 
                  iadd r3.z, r3.z, l(1)  // i<0>
                endloop 
                
                #line 156
                mul r1.x, r1.x, r3.y
                add r4.x, r1.x, r2.x  // intersectPoint<0:NaN:Inf>
                mul r1.x, r1.y, r3.y
                add r4.y, r1.x, r2.y  // intersectPoint<1:NaN:Inf>
                mul r1.x, r1.z, r3.y
                add r4.z, r1.x, r2.z  // intersectPoint<2:NaN:Inf>
                
                #line 161
                mov r4.x, r4.x  // Intersect<0:NaN:Inf>
                mov r4.y, r4.y  // Intersect<1:NaN:Inf>
                mov r4.z, r4.z  // Intersect<2:NaN:Inf>
                
                #line 193
                mov r4.xyz, r4.xyzx  // reflect_point<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                sample_indexable(texturecube)(float,float,float,float) r1.xyz, r4.xyzx, t0.xyzw, s0
                mov r1.xyz, r1.xyzx  // ReflectColor<0:Inf,1:Inf,2:Inf>
                
                #line 198
                mul r3.y, r0.w, r0.w
                mov r3.y, -r3.y
                add r3.y, r3.y, l(1.000000)
                mul r3.y, r3.y, l(0.810000)
                mov r3.y, -r3.y
                add r3.y, r3.y, l(1.000000)
                sqrt r3.z, r3.y
                mul r0.w, r0.w, l(0.900000)
                add r0.w, r3.z, r0.w
                ge r3.y, r3.y, l(0.000000)
                mul r4.xyz, r0.xyzx, l(0.900000, 0.900000, 0.900000, 0.000000)
                mul r5.xyz, r0.wwww, v2.xyzx
                mov r5.xyz, -r5.xyzx
                add r4.xyz, r4.xyzx, r5.xyzx
                movc r3.yzw, r3.yyyy, r4.xxyz, l(0,0,0,0)
                dp3 r0.w, r3.yzwy, r3.yzwy
                rsq r0.w, r0.w
                mul r3.yzw, r0.wwww, r3.yyzw  // refractionvector<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                nop 
                mov r3.yzw, r3.yyzw  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 117
                ne r0.w, r3.y, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.x
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.y
                  mov x1[0].x, r4.x  // t<0>
                else 
                
                #line 120
                  mov x1[0].x, l(-1.000000)  // t<0>
                
                #line 117
                endif 
                
                #line 122
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r4.x, -r2.x
                  add r0.w, r0.w, r4.x
                  div r0.w, r0.w, r3.y
                  mov x1[1].x, r0.w  // t<1>
                else 
                
                #line 125
                  mov x1[1].x, l(-1.000000)  // t<1>
                
                #line 122
                endif 
                
                #line 127
                ne r0.w, r3.z, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.y
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.z
                  mov x1[2].x, r4.x  // t<2>
                else 
                
                #line 130
                  mov x1[2].x, l(-1.000000)  // t<2>
                
                #line 127
                endif 
                
                #line 132
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r4.x, -r2.y
                  add r0.w, r0.w, r4.x
                  div r0.w, r0.w, r3.z
                  mov x1[3].x, r0.w  // t<3>
                else 
                
                #line 135
                  mov x1[3].x, l(-1.000000)  // t<3>
                
                #line 132
                endif 
                
                #line 137
                ne r0.w, r3.w, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.z
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.w
                  mov x1[4].x, r4.x  // t<4>
                else 
                
                #line 140
                  mov x1[4].x, l(-1.000000)  // t<4>
                
                #line 137
                endif 
                
                #line 142
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r1.w, -r2.z
                  add r0.w, r0.w, r1.w
                  div r0.w, r0.w, r3.w
                  mov x1[5].x, r0.w  // t<5>
                else 
                
                #line 145
                  mov x1[5].x, l(-1.000000)  // t<5>
                
                #line 142
                endif 
                
                #line 148
                mov r4.x, r2.w  // tre<0:NaN:Inf>
                mov r4.y, r3.x  // i<0>
                loop 
                  ilt r0.w, r4.y, l(6)
                  breakc_z r0.w
                  mov r0.w, r4.y
                  mov r0.w, x1[r0.w + 0].x  // t<0:NaN:Inf>
                  ge r1.w, r0.w, l(0.000000)
                  lt r4.z, r0.w, r4.x
                  and r1.w, r1.w, r4.z
                  if_nz r1.w
                    mov r4.x, r0.w  // tre<0:NaN:Inf>
                  endif 
                  iadd r4.y, r4.y, l(1)  // i<0>
                endloop 
                
                #line 156
                mul r0.w, r3.y, r4.x
                add r5.x, r0.w, r2.x  // intersectPoint<0:NaN:Inf>
                mul r0.w, r3.z, r4.x
                add r5.y, r0.w, r2.y  // intersectPoint<1:NaN:Inf>
                mul r0.w, r3.w, r4.x
                add r5.z, r0.w, r2.z  // intersectPoint<2:NaN:Inf>
                
                #line 161
                mov r5.x, r5.x  // Intersect<0:NaN:Inf>
                mov r5.y, r5.y  // Intersect<1:NaN:Inf>
                mov r5.z, r5.z  // Intersect<2:NaN:Inf>
                
                #line 199
                mov r5.xyz, r5.xyzx  // refract_point<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                sample_indexable(texturecube)(float,float,float,float) r2.xyzw, r5.xyzx, t0.xyzw, s0  // RefractColor<0:Inf,1:Inf,2:Inf,3:Inf>
                
                #line 209
                mov r0.xyz, -r0.xyzx
                dp3 r0.x, r0.xyzx, v2.xyzx
                mov r0.x, -r0.x
                add r0.x, r0.x, l(1.000000)
                mul r0.y, r0.x, l(1.000000)
                mul r0.x, r0.x, r0.x
                mul r0.x, r0.x, r0.x
                mul r0.x, r0.x, r0.y
                mul r0.x, r0.x, l(0.979630)
                add r0.x, r0.x, l(0.020370)  // fastFresnel<0:NaN:Inf>
                
                #line 217
                mul r0.yzw, r0.xxxx, r1.xxyz
                add r1.xyz, r0.yzwy, l(0.000000, 0.000000, 0.000000, 0.000000)  // Color<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov r1.w, l(1.000000)  // Color<3: 1f>
                mov r0.x, -r0.x
                add r0.x, r0.x, l(1.000000)
                mul r0.xyzw, r0.xxxx, r2.xyzw
                add r0.xyzw, r0.xyzw, r1.xyzw  // Color<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                
                #line 223
                mov o0.xyzw, r0.xyzw  // PS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                ret 
                // Approximately 223 instruction slots used
                            
            };
        }

    }

    technique11 ShadowTech
    {
        pass P0
        {
            VertexShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64
                //   float4x4 matWorld;                 // Offset:   64 Size:    64
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64
                //   float3 EyePos;                     // Offset:  192 Size:    12 [unused]
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4 [unused]
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // POSITION                 0   xyz         0     NONE  float   xyz 
                // NORMAL                   0   xyz         1     NONE  float   xyz 
                // TEXCOORD                 0   xy          2     NONE  float   xy  
                // SIZE                     0   xy          3     NONE  float   xy  
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float   xyzw
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float   xy  
                // SIZE                     0     zw        3     NONE  float     zw
                // TEXCOORD                 1   xyz         4     NONE  float   xyz 
                //
                vs_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[11], immediateIndexed
                dcl_input v0.xyz
                dcl_input v1.xyz
                dcl_input v2.xy
                dcl_input v3.xy
                dcl_output_siv o0.xyzw, position
                dcl_output o1.xyz
                dcl_output o2.xyz
                dcl_output o3.xy
                dcl_output o3.zw
                dcl_output o4.xyz
                dcl_temps 5
                
                #line 57 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, v0.xyzx  // vout<12,13,14>
                mov r1.xyz, v0.xyzx
                mov r1.w, l(1.000000)
                dp4 r2.x, r1.xyzw, cb0[0].xyzw  // vout<0:NaN:Inf>
                dp4 r2.y, r1.xyzw, cb0[1].xyzw  // vout<1:NaN:Inf>
                dp4 r2.z, r1.xyzw, cb0[2].xyzw  // vout<2:NaN:Inf>
                dp4 r2.w, r1.xyzw, cb0[3].xyzw  // vout<3:NaN:Inf>
                dp4 r3.x, r1.xyzw, cb0[4].xyzw  // vout<4:NaN:Inf>
                dp4 r3.y, r1.xyzw, cb0[5].xyzw  // vout<5:NaN:Inf>
                dp4 r3.z, r1.xyzw, cb0[6].xyzw  // vout<6:NaN:Inf>
                dp3 r1.x, v1.xyzx, cb0[8].xyzx
                dp3 r1.y, v1.xyzx, cb0[9].xyzx
                dp3 r1.z, v1.xyzx, cb0[10].xyzx
                dp3 r0.w, r1.xyzx, r1.xyzx
                rsq r0.w, r0.w
                mul r1.xyz, r0.wwww, r1.xyzx  // vout<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov r4.xy, v2.xyxx  // vout<10,11>
                mov r4.zw, v3.xxxy  // vout<15,16>
                
                #line 65
                mov o0.xyzw, r2.xyzw  // VS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                mov o3.xy, r4.xyxx  // VS<10,11>
                mov o3.zw, r4.zzzw  // VS<15,16>
                mov o1.xyz, r3.xyzx  // VS<4:NaN:Inf,5:NaN:Inf,6:NaN:Inf>
                mov o2.xyz, r1.xyzx  // VS<7:NaN:Inf,8:NaN:Inf,9:NaN:Inf>
                mov o4.xyz, r0.xyzx  // VS<12,13,14>
                ret 
                // Approximately 25 instruction slots used
                            
            };
            GeometryShader = NULL;
            PixelShader = asm {
                //
                // Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
                //
                //
                // Buffer Definitions: 
                //
                // cbuffer cbObject
                // {
                //
                //   float4x4 matWorldViewProj;         // Offset:    0 Size:    64 [unused]
                //   float4x4 matWorld;                 // Offset:   64 Size:    64 [unused]
                //   float4x4 matWorldInverseTranspose; // Offset:  128 Size:    64 [unused]
                //   float3 EyePos;                     // Offset:  192 Size:    12
                //   float3 LightDir;                   // Offset:  208 Size:    12 [unused]
                //   float SkyBoxRange;                 // Offset:  220 Size:     4
                //   float2 TexUV[4];                   // Offset:  224 Size:    56 [unused]
                //      = 0x00000000 0x00000000 0x00000000 0x00000000 
                //        0x3f800000 0x00000000 0x00000000 0x00000000 
                //        0x00000000 0x3f800000 0x00000000 0x00000000 
                //        0x3f800000 0x3f800000 
                //
                // }
                //
                //
                // Resource Bindings:
                //
                // Name                                 Type  Format         Dim Slot Elements
                // ------------------------------ ---------- ------- ----------- ---- --------
                // samAnisotropic                    sampler      NA          NA    0        1
                // gCubeTexture                      texture  float4        cube    0        1
                // cbObject                          cbuffer      NA          NA    0        1
                //
                //
                //
                // Input signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_POSITION              0   xyzw        0      POS  float       
                // POSITION                 0   xyz         1     NONE  float   xyz 
                // NORMAL                   0   xyz         2     NONE  float   xyz 
                // TEXCOORD                 0   xy          3     NONE  float       
                // SIZE                     0     zw        3     NONE  float       
                // TEXCOORD                 1   xyz         4     NONE  float       
                //
                //
                // Output signature:
                //
                // Name                 Index   Mask Register SysValue Format   Used
                // -------------------- ----- ------ -------- -------- ------ ------
                // SV_Target                0   xyzw        0   TARGET  float   xyzw
                //
                ps_5_0
                dcl_globalFlags refactoringAllowed
                dcl_constantbuffer cb0[14], immediateIndexed
                dcl_sampler s0, mode_default
                dcl_resource_texturecube (float,float,float,float) t0
                dcl_input_ps linear v1.xyz
                dcl_input_ps linear v2.xyz
                dcl_output o0.xyzw
                dcl_temps 6
                dcl_indexableTemp x0[6], 4
                dcl_indexableTemp x1[6], 4
                
                #line 173 "F:\VS2012pro\D3D11SPH\D3D11SPH\Texture.fx"
                mov r0.xyz, -v1.xyzx
                add r0.xyz, r0.xyzx, cb0[12].xyzx
                dp3 r0.w, r0.xyzx, r0.xyzx
                rsq r0.w, r0.w
                mul r0.xyz, r0.wwww, r0.xyzx  // PostoEye<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 190
                dp3 r0.w, r0.xyzx, r0.xyzx
                rsq r0.w, r0.w
                mul r0.xyz, r0.wwww, r0.xyzx
                mov r0.xyz, -r0.xyzx  // incident<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                dp3 r0.w, r0.xyzx, v2.xyzx
                add r1.x, r0.w, r0.w
                mov r1.x, -r1.x
                mul r1.xyz, r1.xxxx, v2.xyzx
                add r1.xyz, r0.xyzx, r1.xyzx
                dp3 r1.w, r1.xyzx, r1.xyzx
                rsq r1.w, r1.w
                mul r1.xyz, r1.wwww, r1.xyzx  // reflectionvector<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                nop 
                mov r2.xyz, v1.xyzx  // p<0,1,2>
                mov r1.xyz, r1.xyzx  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 115
                mov r1.w, cb0[13].w  // range<0>
                ne r2.w, r1.x, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.x
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.x
                  mov x0[0].x, r3.x  // t<0>
                else 
                
                #line 120
                  mov x0[0].x, l(-1.000000)  // t<0>
                
                #line 117
                endif 
                
                #line 122
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.x
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.x
                  mov x0[1].x, r2.w  // t<1>
                else 
                
                #line 125
                  mov x0[1].x, l(-1.000000)  // t<1>
                
                #line 122
                endif 
                
                #line 127
                ne r2.w, r1.y, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.y
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.y
                  mov x0[2].x, r3.x  // t<2>
                else 
                
                #line 130
                  mov x0[2].x, l(-1.000000)  // t<2>
                
                #line 127
                endif 
                
                #line 132
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.y
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.y
                  mov x0[3].x, r2.w  // t<3>
                else 
                
                #line 135
                  mov x0[3].x, l(-1.000000)  // t<3>
                
                #line 132
                endif 
                
                #line 137
                ne r2.w, r1.z, l(0.000000)
                if_nz r2.w
                  mov r3.x, -r2.z
                  add r3.x, r1.w, r3.x
                  div r3.x, r3.x, r1.z
                  mov x0[4].x, r3.x  // t<4>
                else 
                
                #line 140
                  mov x0[4].x, l(-1.000000)  // t<4>
                
                #line 137
                endif 
                
                #line 142
                if_nz r2.w
                  mov r2.w, -r1.w
                  mov r3.x, -r2.z
                  add r2.w, r2.w, r3.x
                  div r2.w, r2.w, r1.z
                  mov x0[5].x, r2.w  // t<5>
                else 
                
                #line 145
                  mov x0[5].x, l(-1.000000)  // t<5>
                
                #line 142
                endif 
                
                #line 147
                mov r2.w, l(100000.000000)  // tre<0: 100000f>
                mov r3.x, l(0)  // i<0: 0>
                mov r3.y, r2.w  // tre<0:NaN:Inf>
                mov r3.z, r3.x  // i<0>
                loop 
                  ilt r3.w, r3.z, l(6)
                  breakc_z r3.w
                  mov r3.w, r3.z
                  mov r3.w, x0[r3.w + 0].x  // t<0:NaN:Inf>
                  ge r4.x, r3.w, l(0.000000)
                  lt r4.y, r3.w, r3.y
                  and r4.x, r4.y, r4.x
                  if_nz r4.x
                    mov r3.y, r3.w  // tre<0:NaN:Inf>
                  endif 
                  iadd r3.z, r3.z, l(1)  // i<0>
                endloop 
                
                #line 156
                mul r1.x, r1.x, r3.y
                add r4.x, r1.x, r2.x  // intersectPoint<0:NaN:Inf>
                mul r1.x, r1.y, r3.y
                add r4.y, r1.x, r2.y  // intersectPoint<1:NaN:Inf>
                mul r1.x, r1.z, r3.y
                add r4.z, r1.x, r2.z  // intersectPoint<2:NaN:Inf>
                
                #line 161
                mov r4.x, r4.x  // Intersect<0:NaN:Inf>
                mov r4.y, r4.y  // Intersect<1:NaN:Inf>
                mov r4.z, r4.z  // Intersect<2:NaN:Inf>
                
                #line 193
                mov r4.xyz, r4.xyzx  // reflect_point<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                sample_indexable(texturecube)(float,float,float,float) r1.xyz, r4.xyzx, t0.xyzw, s0
                mov r1.xyz, r1.xyzx  // ReflectColor<0:Inf,1:Inf,2:Inf>
                
                #line 198
                mul r3.y, r0.w, r0.w
                mov r3.y, -r3.y
                add r3.y, r3.y, l(1.000000)
                mul r3.y, r3.y, l(0.810000)
                mov r3.y, -r3.y
                add r3.y, r3.y, l(1.000000)
                sqrt r3.z, r3.y
                mul r0.w, r0.w, l(0.900000)
                add r0.w, r3.z, r0.w
                ge r3.y, r3.y, l(0.000000)
                mul r4.xyz, r0.xyzx, l(0.900000, 0.900000, 0.900000, 0.000000)
                mul r5.xyz, r0.wwww, v2.xyzx
                mov r5.xyz, -r5.xyzx
                add r4.xyz, r4.xyzx, r5.xyzx
                movc r3.yzw, r3.yyyy, r4.xxyz, l(0,0,0,0)
                dp3 r0.w, r3.yzwy, r3.yzwy
                rsq r0.w, r0.w
                mul r3.yzw, r0.wwww, r3.yyzw  // refractionvector<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                nop 
                mov r3.yzw, r3.yyzw  // v<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                
                #line 117
                ne r0.w, r3.y, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.x
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.y
                  mov x1[0].x, r4.x  // t<0>
                else 
                
                #line 120
                  mov x1[0].x, l(-1.000000)  // t<0>
                
                #line 117
                endif 
                
                #line 122
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r4.x, -r2.x
                  add r0.w, r0.w, r4.x
                  div r0.w, r0.w, r3.y
                  mov x1[1].x, r0.w  // t<1>
                else 
                
                #line 125
                  mov x1[1].x, l(-1.000000)  // t<1>
                
                #line 122
                endif 
                
                #line 127
                ne r0.w, r3.z, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.y
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.z
                  mov x1[2].x, r4.x  // t<2>
                else 
                
                #line 130
                  mov x1[2].x, l(-1.000000)  // t<2>
                
                #line 127
                endif 
                
                #line 132
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r4.x, -r2.y
                  add r0.w, r0.w, r4.x
                  div r0.w, r0.w, r3.z
                  mov x1[3].x, r0.w  // t<3>
                else 
                
                #line 135
                  mov x1[3].x, l(-1.000000)  // t<3>
                
                #line 132
                endif 
                
                #line 137
                ne r0.w, r3.w, l(0.000000)
                if_nz r0.w
                  mov r4.x, -r2.z
                  add r4.x, r1.w, r4.x
                  div r4.x, r4.x, r3.w
                  mov x1[4].x, r4.x  // t<4>
                else 
                
                #line 140
                  mov x1[4].x, l(-1.000000)  // t<4>
                
                #line 137
                endif 
                
                #line 142
                if_nz r0.w
                  mov r0.w, -r1.w
                  mov r1.w, -r2.z
                  add r0.w, r0.w, r1.w
                  div r0.w, r0.w, r3.w
                  mov x1[5].x, r0.w  // t<5>
                else 
                
                #line 145
                  mov x1[5].x, l(-1.000000)  // t<5>
                
                #line 142
                endif 
                
                #line 148
                mov r4.x, r2.w  // tre<0:NaN:Inf>
                mov r4.y, r3.x  // i<0>
                loop 
                  ilt r0.w, r4.y, l(6)
                  breakc_z r0.w
                  mov r0.w, r4.y
                  mov r0.w, x1[r0.w + 0].x  // t<0:NaN:Inf>
                  ge r1.w, r0.w, l(0.000000)
                  lt r4.z, r0.w, r4.x
                  and r1.w, r1.w, r4.z
                  if_nz r1.w
                    mov r4.x, r0.w  // tre<0:NaN:Inf>
                  endif 
                  iadd r4.y, r4.y, l(1)  // i<0>
                endloop 
                
                #line 156
                mul r0.w, r3.y, r4.x
                add r5.x, r0.w, r2.x  // intersectPoint<0:NaN:Inf>
                mul r0.w, r3.z, r4.x
                add r5.y, r0.w, r2.y  // intersectPoint<1:NaN:Inf>
                mul r0.w, r3.w, r4.x
                add r5.z, r0.w, r2.z  // intersectPoint<2:NaN:Inf>
                
                #line 161
                mov r5.x, r5.x  // Intersect<0:NaN:Inf>
                mov r5.y, r5.y  // Intersect<1:NaN:Inf>
                mov r5.z, r5.z  // Intersect<2:NaN:Inf>
                
                #line 199
                mov r5.xyz, r5.xyzx  // refract_point<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                sample_indexable(texturecube)(float,float,float,float) r2.xyzw, r5.xyzx, t0.xyzw, s0  // RefractColor<0:Inf,1:Inf,2:Inf,3:Inf>
                
                #line 209
                mov r0.xyz, -r0.xyzx
                dp3 r0.x, r0.xyzx, v2.xyzx
                mov r0.x, -r0.x
                add r0.x, r0.x, l(1.000000)
                mul r0.y, r0.x, l(1.000000)
                mul r0.x, r0.x, r0.x
                mul r0.x, r0.x, r0.x
                mul r0.x, r0.x, r0.y
                mul r0.x, r0.x, l(0.979630)
                add r0.x, r0.x, l(0.020370)  // fastFresnel<0:NaN:Inf>
                
                #line 217
                mul r0.yzw, r0.xxxx, r1.xxyz
                add r1.xyz, r0.yzwy, l(0.000000, 0.000000, 0.000000, 0.000000)  // Color<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
                mov r1.w, l(1.000000)  // Color<3: 1f>
                mov r0.x, -r0.x
                add r0.x, r0.x, l(1.000000)
                mul r0.xyzw, r0.xxxx, r2.xyzw
                add r0.xyzw, r0.xyzw, r1.xyzw  // Color<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                
                #line 223
                mov o0.xyzw, r0.xyzw  // PS<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
                ret 
                // Approximately 223 instruction slots used
                            
            };
        }

    }

}

